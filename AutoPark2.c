#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     HTIRS2,         sensorI2CCustom)
#pragma config(Sensor, S3,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S4,     LiftDownTouch,  sensorTouch)
#pragma config(Motor,  mtr_S1_C1_1,     LiftA,         tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     LiftB,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     BackLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     FrontLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     FrontRight,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     BackRight,     tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    BallRelease,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    FourBarLink,          tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    KickStand,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    Tow,                  tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#define DRIVE_FORWARD 0// #defines for InchDrive
#define DRIVE_BACK 1
#define STRAFE_RIGHT 2
#define STRAFE_LEFT 3

#include "RBButtonLib.h";//Button librarie
#include "JoystickDriver.c";  //Include file to "handle" the Bluetooth messages.
RB_Button_State ButtonState;
#include "SemiAutoLiftLib.c"// lift librarie
#include "lego-ultrasound.h"//US librarie
void initializeRobot()//initialise function
{
	int USValue = SensorValue(sonarSensor);// initialise US
	servo[BallRelease] =  0;// set servos to down position
	servo[FourBarLink] = 0;
	servo[KickStand] =0;
	servo[Tow] = 0;
	if (! SensorValue[LiftDownTouch])//if NOT bottom button is pressed warn driver to go down
	{
		playTone(1000,500); // 1000Hz for 1/2sec
	}
}
void InchDrive(int Action, int DriveXin)// move by inches function
{
	writeDebugStreamLine("STARTING INCHDRIVE");
	if(DriveXin < 0) return;// if set value is < 0 stop
	int MotorRunTime = 0;//delay value

	int Brake1 = 8;//these value  are correct for 50% motor speed
	float Brake1MS = 52.11;// ms per inch for after 8in

	int Brake2 = 17;
	float Brake2MS = 46.79;//ms per inch for after 17in

	int Brake3 = 25;
	float Brake3MS = 43.90;//ms per inch for after 25in

	float Brake4MS = 43.90;//ms per inch for after 25in


	//average	8, 17, 25
	//MsPerInch	88.75, 68.89, 66.51

	if(DriveXin >= Brake1)//if set value > 8in
	{
		writeDebugStreamLine("BREAK1");
		if (DriveXin >= Brake2)//if set value > 17in
		{
			writeDebugStreamLine("BREAK2");
			if(DriveXin >= Brake3)//if set value > 25in
			{
				writeDebugStreamLine("BREAK3");
				MotorRunTime = Brake1 * Brake1MS;
				DriveXin -= Brake1;
				MotorRunTime += (Brake2 - Brake1) * Brake2MS;
				DriveXin -= (Brake2-Brake1);
				MotorRunTime += (Brake3 - Brake2) * Brake3MS;
				DriveXin -= (Brake3 - Brake2);
				MotorRunTime += DriveXin * Brake4MS;
			}
			else//if set value > 17in
			{
				MotorRunTime = Brake1 * Brake1MS;
				DriveXin -= Brake1;
				MotorRunTime += (Brake2 - Brake1) * Brake2MS;
				DriveXin -= (Brake2-Brake1);
				MotorRunTime += DriveXin * Brake3MS;
			}
		}
		else//if set value > 8in
		{
			MotorRunTime = Brake1 * Brake1MS;
			DriveXin -= Brake1;
			MotorRunTime += DriveXin * Brake2MS;
		}
	}
	else//if set value < 8in
	{
		MotorRunTime = DriveXin * Brake1MS;
	}
	writeDebugStreamLine("RUNNING MOTORS");
	switch (Action)// allow for driving back or forward or strafing left or right
	{
	case DRIVE_FORWARD:
		motor[FrontRight]=50;
		motor[FrontLeft]=-50;
		motor[BackRight]=50;
		motor[BackLeft]=-50;
		break;
	case DRIVE_BACK:
		motor[FrontRight]=-50;
		motor[FrontLeft]=50;
		motor[BackRight]=-50;
		motor[BackLeft]=50;
		break;
	case STRAFE_RIGHT:
		motor[FrontRight]=-50;
		motor[FrontLeft]=-50;
		motor[BackRight]=50;
		motor[BackLeft]=50;
		break;
	case STRAFE_LEFT:
		motor[FrontRight]=50;
		motor[FrontLeft]=50;
		motor[BackRight]=-50;
		motor[BackLeft]=-50;
		break;

	default:
		break;
	}
	writeDebugStreamLine("Delay %d ms",MotorRunTime);

	sleep(MotorRunTime);//sleep number of MS
	motor[FrontRight]=0;//stop motors
	motor[FrontLeft]=-0;
	motor[BackRight]=0;
	motor[BackLeft]=-0;
	writeDebugStreamLine("FINISHED INCHDRIVE");

}
int cGFinder() // center goal finder
{
	writeDebugStreamLine("STARTING CGP FINDER");
	int cGPosition = 0;
	int USValue = SensorValue(sonarSensor);// read US
	writeDebugStreamLine("uSCDist: %d",USValue );
	//If CGP = 3, US = ~50cm from sensor// estimated values for each CGP
	//If CGP = 2, US = ~155cm
	//If CGP = 1, US = ~29cm
	if(USValue < 36)// if US sees CG
	{
		cGPosition = 1;
	}
	writeDebugStreamLine("FINISHED CGP FINDER");
	return cGPosition;
}
task main()
{
	// robot starts right side of robot touching wall & FR wheel in corner.
	initializeRobot();// initializes robot
	startTask(LiftTeleOP);// starts lift function
	DesiredFloor = 2;// take lift to 60cm height
	motor[FrontLeft]=75;//Diagonal move backward
	motor[BackRight]=-75;
	sleep(2600);// hard-coded value of time moving the motors
	motor[FrontRight]=75;
	motor[FrontLeft]=75;
	motor[BackRight]=-75;
	sleep(25);// do this to prevent the robot from twisting slightly.
	motor[BackLeft]=-75;
	sleep(1000);// hard-coded value of time moving the motors
	motor[FrontRight]=0;// stop robot
	motor[FrontLeft]=0;
	motor[BackRight]=0;
	motor[BackLeft]=0;
	sleep(250);
	int CGFound = cGFinder();// ping US to find CG
	time1[T1]=0;//timer
	int pings = 0;
	while((time1[T1] <= 3000) && (CGFound == 0))// do a arc until CG is found or 3 seconds time-out reached.
	{
		motor[FrontRight]=-17;
		motor[FrontLeft]=-17;
		motor[BackRight]=53;
		motor[BackLeft]=53;
		CGFound = cGFinder();
		pings++;// Number of pings during arc
	}
	motor[FrontRight]=0;//stop robot
	motor[FrontLeft]=0;
	motor[BackRight]=0;
	motor[BackLeft]=0;
	sleep(100);
	// Begin scoring
	if (CGFound == 1)// dont score unless CG is found
	{
		InchDrive(DRIVE_BACK,4);// go back 4in
		DesiredFloor = 4;// take lift to 120cm height

		while(GetLiftEnc() <  (FloorHeight[DesiredFloor]- LiftEncGap))//dont move until lift has stopped
		{
			writeDebugStreamLine("GetLiftEnc:%d", GetLiftEnc() );
			sleep(100);
		}
		sleep(250);
		InchDrive(DRIVE_FORWARD, 5);// go forward 5in
		sleep(50);// wait a small bit to make sure lift is stable
		servo[BallRelease] = 90;//open scoring mechanism
		sleep(1000);// make sure balls are out
		servo[BallRelease] = 0;// close scoring mechanism 
		InchDrive(DRIVE_BACK, 5);// go back 5in
		DesiredFloor = 0;// lower lift down to 0.
	}
	else// if CG not found lower lift to 0
	{
		DesiredFloor = 0;
	}
	//displayBigTextLine(0, "# of pings:%d", pings);
	writeDebugStreamLine("# of pings:%d", pings );// total number of US pings
}
s